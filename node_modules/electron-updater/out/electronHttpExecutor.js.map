{"version":3,"sources":["../src/electronHttpExecutor.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;;;;AAIM,MAAA,oBAAA,SAAoC,kCAApC,CAAwE;AAC5E,cAA6B,kBAA7B,EAAkG;AAChG;AAD2B,SAAA,kBAAA,GAAA,kBAAA;AAE5B;;AAEK,UAAN,CAAe,GAAf,EAA4B,WAA5B,EAAiD,OAAjD,EAAyE;AAAA;;AAAA;AACvE,UAAI,WAAW,IAAX,IAAmB,CAAC,QAAQ,eAAhC,EAAiD;AAC/C,cAAM,2BAAU,KAAK,OAAL,CAAa,WAAb,CAAV,CAAN;AACD;;AAED,aAAO,MAAM,QAAQ,iBAAR,CAA0B,aAA1B,CAAgD,CAAC,OAAD,EAAU,MAAV,EAAkB,QAAlB,KAA8B;AACzF,cAAK,UAAL,CAAe,OAAA,MAAA,CAAA,EAAA,EACV,0DAA+B,GAA/B,EAAoC;AACrC,mBAAS,QAAQ,OAAR,IAAmB;AADS,SAApC,CADU,EAGX;AACF,oBAAU;AADR,SAHW,CAAf,EAKG,WALH,EAKgB,CALhB,EAKmB,OALnB,EAK4B,SAAQ;AAClC,cAAI,SAAS,IAAb,EAAmB;AACjB,oBAAQ,WAAR;AACD,WAFD,MAGK;AACH,mBAAO,KAAP;AACD;AACF,SAZD,EAYG,QAZH;AAaD,OAdY,CAAb;AALuE;AAoBxE;;AAEM,YAAU,OAAV,EAAwB,QAAxB,EAAyD;AAC9D,UAAM,UAAU,gBAAI,OAAJ,CAAY,OAAZ,CAAhB;;AACA,YAAQ,EAAR,CAAW,UAAX,EAAuB,QAAvB;AACA,SAAK,oBAAL,CAA0B,OAA1B;AACA,WAAO,OAAP;AACD;;AAEO,uBAAqB,OAArB,EAAoD;AAC1D,QAAI,KAAK,kBAAL,IAA2B,IAA/B,EAAqC;AACnC,cAAQ,EAAR,CAAW,OAAX,EAAoB,KAAK,kBAAzB;AACD;AACF;;AAES,sBAAoB,OAApB,EAAkC,OAAlC,EAA2D,MAA3D,EAA2F,aAA3F,EAAkH,OAAlH,EAA4J;AACpK,YAAQ,EAAR,CAAW,UAAX,EAAuB,CAAC,UAAD,EAAqB,MAArB,EAAqC,WAArC,KAA4D;AACjF,UAAI,gBAAgB,EAApB,EAAwB;AACtB,eAAO,IAAI,KAAJ,CAAU,2BAAV,CAAP;AACA;AACD;;AAED,cAAQ,mCAAa,yBAAb,CAAuC,WAAvC,EAAoD,OAApD,CAAR;AACD,KAPD;AAQD;;AAjD2E","sourcesContent":["import { configureRequestOptionsFromUrl, DownloadOptions, HttpExecutor } from \"builder-util-runtime\"\nimport { net } from \"electron\"\nimport { ensureDir } from \"fs-extra-p\"\nimport { RequestOptions } from \"http\"\nimport * as path from \"path\"\n\nexport type LoginCallback = (username: string, password: string) => void\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.ClientRequest> {\n  constructor(private readonly proxyLoginCallback?: (authInfo: any, callback: LoginCallback) => void) {\n    super()\n  }\n\n  async download(url: string, destination: string, options: DownloadOptions): Promise<string> {\n    if (options == null || !options.skipDirCreation) {\n      await ensureDir(path.dirname(destination))\n    }\n\n    return await options.cancellationToken.createPromise<string>((resolve, reject, onCancel) => {\n      this.doDownload({\n        ...configureRequestOptionsFromUrl(url, {\n          headers: options.headers || undefined,\n        }),\n        redirect: \"manual\",\n      }, destination, 0, options, error => {\n        if (error == null) {\n          resolve(destination)\n        }\n        else {\n          reject(error)\n        }\n      }, onCancel)\n    })\n  }\n\n  public doRequest(options: any, callback: (response: any) => void): any {\n    const request = net.request(options)\n    request.on(\"response\", callback)\n    this.addProxyLoginHandler(request)\n    return request\n  }\n\n  private addProxyLoginHandler(request: Electron.ClientRequest) {\n    if (this.proxyLoginCallback != null) {\n      request.on(\"login\", this.proxyLoginCallback)\n    }\n  }\n\n  protected addRedirectHandlers(request: any, options: RequestOptions, reject: (error: Error) => void, redirectCount: number, handler: (options: RequestOptions) => void) {\n    request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n      if (redirectCount > 10) {\n        reject(new Error(\"Too many redirects (> 10)\"))\n        return\n      }\n\n      handler(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options))\n    })\n  }\n}"],"sourceRoot":""}
