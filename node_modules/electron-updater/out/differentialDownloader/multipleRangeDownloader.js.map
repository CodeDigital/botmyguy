{"version":3,"sources":["../../src/differentialDownloader/multipleRangeDownloader.ts"],"names":[],"mappings":";;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEM,SAAA,YAAA,CAAuB,sBAAvB,EAAuE,KAAvE,EAAgG,GAAhG,EAA+G,SAA/G,EAAkI,MAAlI,EAAgK;AACpK,QAAM,IAAK,UAAD,IAAuB;AAC/B,QAAI,cAAc,MAAM,MAAxB,EAAgC;AAC9B,UAAI,uBAAuB,kBAAvB,IAA6C,IAAjD,EAAuD;AACrD,YAAI,KAAJ,CAAU,uBAAuB,kBAAjC;AACD;;AACD,UAAI,GAAJ;AACA;AACD;;AAED,UAAM,aAAa,cAAc,uBAAuB,OAAvB,CAA+B,uBAA/B,KAA2D,KAA3D,GAAmE,CAAnE,GAAuE,IAArF,CAAnB;;AACA,kBAAc,sBAAd,EAAsC;AACpC,WADoC;AAEpC,aAAO,UAF6B;AAGpC,WAAK,KAAK,GAAL,CAAS,MAAM,MAAf,EAAuB,UAAvB,CAH+B;AAIpC;AAJoC,KAAtC,EAKG,GALH,EAKQ,MAAM,EAAE,UAAF,CALd,EAK6B,MAL7B;AAMD,GAhBD;;AAiBA,SAAO,CAAP;AACD;;AAEK,SAAA,aAAA,CAAwB,sBAAxB,EAAwE,OAAxE,EAAmG,GAAnG,EAAkH,OAAlH,EAAuI,MAAvI,EAAqK;AACzK,MAAI,SAAS,QAAb;AACA,MAAI,YAAY,CAAhB;AACA,QAAM,uBAAuB,IAAI,GAAJ,EAA7B;AACA,QAAM,oBAAmC,EAAzC;;AACA,OAAK,IAAI,IAAI,QAAQ,KAArB,EAA4B,IAAI,QAAQ,GAAxC,EAA6C,GAA7C,EAAkD;AAChD,UAAM,OAAO,QAAQ,KAAR,CAAc,CAAd,CAAb;;AACA,QAAI,KAAK,IAAL,KAAc,qCAAc,QAAhC,EAA0C;AACxC,gBAAU,GAAG,KAAK,KAAK,IAAI,KAAK,GAAL,GAAW,CAAC,IAAvC;AACA,2BAAqB,GAArB,CAAyB,SAAzB,EAAoC,CAApC;AACA;AACA,wBAAkB,IAAlB,CAAuB,KAAK,GAAL,GAAW,KAAK,KAAvC;AACD;AACF;;AAED,MAAI,aAAa,CAAjB,EAAoB;AAClB;AACA,UAAM,IAAK,KAAD,IAAkB;AAC1B,UAAI,SAAS,QAAQ,GAArB,EAA0B;AACxB;AACA;AACD;;AAED,YAAM,OAAO,QAAQ,KAAR,CAAc,OAAd,CAAb;;AAEA,UAAI,KAAK,IAAL,KAAc,qCAAc,IAAhC,EAAsC;AACpC,sCAAS,IAAT,EAAe,GAAf,EAAoB,QAAQ,SAA5B,EAAuC,MAAvC,EAA+C,MAAM,EAAE,KAAF,CAArD;AACD,OAFD,MAGK;AACH,cAAM,iBAAiB,uBAAuB,oBAAvB,CAA4C,KAA5C,CAAvB;AACA,uBAAe,OAAf,CAAyB,KAAzB,GAAiC,SAAS,KAAK,KAAK,IAAI,KAAK,GAAL,GAAW,CAAC,EAApE;AACA,cAAM,UAAU,uBAAuB,YAAvB,CAAoC,SAApC,CAA8C,cAA9C,EAA8D,YAAW;AACvF,cAAI,CAAC,uBAAuB,QAAvB,EAAiC,MAAjC,CAAL,EAA+C;AAC7C;AACD;;AAED,mBAAS,IAAT,CAAc,GAAd,EAAmB;AACjB,iBAAK;AADY,WAAnB;AAGA,mBAAS,IAAT,CAAc,KAAd,EAAqB,MAAM,EAAE,KAAF,CAA3B;AACD,SATe,CAAhB;AAUA,+BAAuB,YAAvB,CAAoC,0BAApC,CAA+D,OAA/D,EAAwE,MAAxE;AACA,gBAAQ,GAAR;AACD;AACF,KA3BD;;AA6BA,MAAE,QAAQ,KAAV;AACA;AACD;;AAED,QAAM,iBAAiB,uBAAuB,oBAAvB,CAA4C,KAA5C,CAAvB;AACA,iBAAe,OAAf,CAAyB,KAAzB,GAAiC,OAAO,SAAP,CAAiB,CAAjB,EAAoB,OAAO,MAAP,GAAgB,CAApC,CAAjC;AACA,QAAM,UAAU,uBAAuB,YAAvB,CAAoC,SAApC,CAA8C,cAA9C,EAA8D,YAAW;AACvF,QAAI,CAAC,uBAAuB,QAAvB,EAAiC,MAAjC,CAAL,EAA+C;AAC7C;AACD;;AAED,UAAM,cAAc,yCAAc,QAAd,EAAwB,cAAxB,CAApB;AACA,UAAM,IAAI,8DAA8D,IAA9D,CAAmE,WAAnE,CAAV;;AACA,QAAI,KAAK,IAAT,EAAe;AACb,aAAO,IAAI,KAAJ,CAAU,6DAA6D,WAAW,GAAlF,CAAP;AACA;AACD;;AAED,UAAM,QAAQ,KAAI,4BAAJ,EAAiB,GAAjB,EAAsB,OAAtB,EAA+B,oBAA/B,EAAqD,EAAE,CAAF,KAAQ,EAAE,CAAF,CAA7D,EAAmE,iBAAnE,EAAsF,OAAtF,CAAd;AACA,UAAM,EAAN,CAAS,OAAT,EAAkB,MAAlB;AACA,aAAS,IAAT,CAAc,KAAd;AACD,GAfe,CAAhB;AAgBA,yBAAuB,YAAvB,CAAoC,0BAApC,CAA+D,OAA/D,EAAwE,MAAxE;AACA,UAAQ,GAAR;AACD;;AAEK,SAAA,sBAAA,CAAiC,QAAjC,EAA4D,MAA5D,EAA0F;AAC9F;AACA,MAAI,SAAS,UAAT,IAAyB,GAA7B,EAAkC;AAChC,WAAO,2CAAgB,QAAhB,CAAP;AACA,WAAO,KAAP;AACD;;AAED,MAAI,SAAS,UAAT,KAAwB,GAA5B,EAAiC;AAC/B,UAAM,eAAe,yCAAc,QAAd,EAAwB,eAAxB,CAArB;;AACA,QAAI,gBAAgB,IAAhB,IAAwB,iBAAiB,MAA7C,EAAqD;AACnD,aAAO,IAAI,KAAJ,CAAU,uDAAuD,SAAS,UAAU,GAApF,CAAP;AACA,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD","sourcesContent":["import { createHttpError, safeGetHeader } from \"builder-util-runtime\"\nimport { IncomingMessage } from \"http\"\nimport { Writable } from \"stream\"\nimport { copyData, DataSplitter, PartListDataTask } from \"./DataSplitter\"\nimport { DifferentialDownloader } from \"./DifferentialDownloader\"\nimport { Operation, OperationKind } from \"./downloadPlanBuilder\"\n\nexport function executeTasks(differentialDownloader: DifferentialDownloader, tasks: Array<Operation>, out: Writable, oldFileFd: number, reject: (error: Error) => void) {\n  const w = (taskOffset: number) => {\n    if (taskOffset >= tasks.length) {\n      if (differentialDownloader.fileMetadataBuffer != null) {\n        out.write(differentialDownloader.fileMetadataBuffer)\n      }\n      out.end()\n      return\n    }\n\n    const nextOffset = taskOffset + (differentialDownloader.options.useMultipleRangeRequest === false ? 1 : 1000)\n    _executeTasks(differentialDownloader, {\n      tasks,\n      start: taskOffset,\n      end: Math.min(tasks.length, nextOffset),\n      oldFileFd,\n    }, out, () => w(nextOffset), reject)\n  }\n  return w\n}\n\nexport function _executeTasks(differentialDownloader: DifferentialDownloader, options: PartListDataTask, out: Writable, resolve: () => void, reject: (error: Error) => void) {\n  let ranges = \"bytes=\"\n  let partCount = 0\n  const partIndexToTaskIndex = new Map<number, number>()\n  const partIndexToLength: Array<number> = []\n  for (let i = options.start; i < options.end; i++) {\n    const task = options.tasks[i]\n    if (task.kind === OperationKind.DOWNLOAD) {\n      ranges += `${task.start}-${task.end - 1}, `\n      partIndexToTaskIndex.set(partCount, i)\n      partCount++\n      partIndexToLength.push(task.end - task.start)\n    }\n  }\n\n  if (partCount <= 1) {\n    // the only remote range - copy\n    const w = (index: number) => {\n      if (index >= options.end) {\n        resolve()\n        return\n      }\n\n      const task = options.tasks[index++]\n\n      if (task.kind === OperationKind.COPY) {\n        copyData(task, out, options.oldFileFd, reject, () => w(index))\n      }\n      else {\n        const requestOptions = differentialDownloader.createRequestOptions(\"get\")\n        requestOptions.headers!!.Range = `bytes=${task.start}-${task.end - 1}`\n        const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {\n          if (!checkIsRangesSupported(response, reject)) {\n            return\n          }\n\n          response.pipe(out, {\n            end: false\n          })\n          response.once(\"end\", () => w(index))\n        })\n        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n        request.end()\n      }\n    }\n\n    w(options.start)\n    return\n  }\n\n  const requestOptions = differentialDownloader.createRequestOptions(\"get\")\n  requestOptions.headers!!.Range = ranges.substring(0, ranges.length - 2)\n  const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {\n    if (!checkIsRangesSupported(response, reject)) {\n      return\n    }\n\n    const contentType = safeGetHeader(response, \"content-type\")\n    const m = /^multipart\\/.+?(?:; boundary=(?:(?:\"(.+)\")|(?:([^\\s]+))))$/i.exec(contentType)\n    if (m == null) {\n      reject(new Error(`Content-Type \"multipart/byteranges\" is expected, but got \"${contentType}\"`))\n      return\n    }\n\n    const dicer = new DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve)\n    dicer.on(\"error\", reject)\n    response.pipe(dicer)\n  })\n  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n  request.end()\n}\n\nexport function checkIsRangesSupported(response: IncomingMessage, reject: (error: Error) => void): boolean {\n  // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\n  if (response.statusCode!! >= 400) {\n    reject(createHttpError(response))\n    return false\n  }\n\n  if (response.statusCode !== 206) {\n    const acceptRanges = safeGetHeader(response, \"accept-ranges\")\n    if (acceptRanges == null || acceptRanges === \"none\") {\n      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`))\n      return false\n    }\n  }\n  return true\n}"],"sourceRoot":""}
