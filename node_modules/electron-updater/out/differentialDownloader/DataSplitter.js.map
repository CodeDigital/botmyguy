{"version":3,"sources":["../../src/differentialDownloader/DataSplitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { newError } from \"builder-util-runtime\"\nimport { createReadStream } from \"fs-extra-p\"\nimport { Writable } from \"stream\"\nimport { Operation, OperationKind } from \"./downloadPlanBuilder\"\n\nconst DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\")\n\nenum ReadState {\n  INIT, HEADER, BODY\n}\n\nexport interface PartListDataTask {\n  readonly oldFileFd: number\n  readonly tasks: Array<Operation>\n  readonly start: number\n  readonly end: number\n}\n\nexport function copyData(task: Operation, out: Writable, oldFileFd: number, reject: (error: Error) => void, resolve: () => void) {\n  const readStream = createReadStream(\"\", {\n    fd: oldFileFd,\n    autoClose: false,\n    start: task.start,\n    // end is inclusive\n    end: task.end - 1,\n  })\n  readStream.on(\"error\", reject)\n  readStream.once(\"end\", resolve)\n  readStream.pipe(out, {\n    end: false\n  })\n}\n\nexport class DataSplitter extends Writable {\n  partIndex = -1\n\n  private headerListBuffer: Buffer | null = null\n  private readState = ReadState.INIT\n  private ignoreByteCount = 0\n  private remainingPartDataCount = 0\n\n  private readonly boundaryLength: number\n\n  constructor(private readonly out: Writable, private readonly options: PartListDataTask, private readonly partIndexToTaskIndex: Map<number, number>, boundary: string, private readonly partIndexToLength: Array<number>, private readonly finishHandler: () => any) {\n    super()\n\n    this.boundaryLength = boundary.length + 4 /* size of \\r\\n-- */\n    // first chunk doesn't start with \\r\\n\n    this.ignoreByteCount = this.boundaryLength - 2\n  }\n\n  get isFinished() {\n    return this.partIndex === this.partIndexToLength.length\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  _write(data: Buffer, encoding: string, callback: (error?: Error) => void) {\n    if (this.isFinished) {\n      console.error(`Trailing ignored data: ${data.length} bytes`)\n      return\n    }\n\n    this.handleData(data)\n      .then(callback)\n      .catch(callback)\n  }\n\n  private async handleData(chunk: Buffer): Promise<undefined> {\n    let start = 0\n\n    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\n      throw newError(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\")\n    }\n\n    if (this.ignoreByteCount > 0) {\n      const toIgnore = Math.min(this.ignoreByteCount, chunk.length)\n      this.ignoreByteCount -= toIgnore\n      start = toIgnore\n    }\n    else if (this.remainingPartDataCount > 0) {\n      const toRead = Math.min(this.remainingPartDataCount, chunk.length)\n      this.remainingPartDataCount -= toRead\n      await this.processPartData(chunk, 0, toRead)\n      start = toRead\n    }\n\n    if (start === chunk.length) {\n      return\n    }\n\n    if (this.readState === ReadState.HEADER) {\n      const headerListEnd = this.searchHeaderListEnd(chunk, start)\n      if (headerListEnd === -1) {\n        return\n      }\n\n      start = headerListEnd\n      this.readState = ReadState.BODY\n      // header list is ignored, we don't need it\n      this.headerListBuffer = null\n    }\n\n    while (true) {\n      if (this.readState === ReadState.BODY) {\n        this.readState = ReadState.INIT\n      }\n      else {\n        this.partIndex++\n\n        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex)\n        if (taskIndex == null) {\n          if (this.isFinished) {\n            taskIndex = this.options.end\n          }\n          else {\n            throw newError(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\")\n          }\n        }\n\n        const prevTaskIndex = this.partIndex === 0 ? this.options.start : (this.partIndexToTaskIndex.get(this.partIndex - 1)!! + 1 /* prev part is download, next maybe copy */)\n        if (prevTaskIndex < taskIndex) {\n          await this.copyExistingData(prevTaskIndex, taskIndex)\n        }\n        else if (prevTaskIndex > taskIndex) {\n          throw newError(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\")\n        }\n\n        if (this.isFinished) {\n          this.onPartEnd()\n          this.finishHandler()\n          return\n        }\n\n        start = this.searchHeaderListEnd(chunk, start)\n\n        if (start === -1) {\n          this.readState = ReadState.HEADER\n          return\n        }\n      }\n\n      const partLength = this.partIndexToLength[this.partIndex]\n      const end = start + partLength\n      const effectiveEnd = Math.min(end, chunk.length)\n      await this.processPartStarted(chunk, start, effectiveEnd)\n      this.remainingPartDataCount = partLength - (effectiveEnd - start)\n      if (this.remainingPartDataCount > 0) {\n        return\n      }\n\n      start = end + this.boundaryLength\n      if (start >= chunk.length) {\n        this.ignoreByteCount = this.boundaryLength - (chunk.length - end)\n        return\n      }\n    }\n  }\n\n  private copyExistingData(index: number, end: number) {\n    return new Promise((resolve, reject) => {\n      const w = () => {\n        if (index === end) {\n          resolve()\n          return\n        }\n\n        const task = this.options.tasks[index]\n        if (task.kind !== OperationKind.COPY) {\n          reject(new Error(\"Task kind must be COPY\"))\n          return\n        }\n\n        copyData(task, this.out, this.options.oldFileFd, reject, () => {\n          index++\n          w()\n        })\n      }\n      w()\n    })\n  }\n\n  private searchHeaderListEnd(chunk: Buffer, readOffset: number): number {\n    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset)\n    if (headerListEnd !== -1) {\n      return headerListEnd + DOUBLE_CRLF.length\n    }\n\n    // not all headers data were received, save to buffer\n    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset)\n    if (this.headerListBuffer == null) {\n      this.headerListBuffer = partialChunk\n    }\n    else {\n      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk])\n    }\n    return -1\n  }\n\n  private actualPartLength = 0\n\n  private onPartEnd() {\n    const expectedLength = this.partIndexToLength[this.partIndex - 1]\n    if (this.actualPartLength !== expectedLength) {\n      throw newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\")\n    }\n    this.actualPartLength = 0\n  }\n\n  private processPartStarted(data: Buffer, start: number, end: number): Promise<void> {\n    if (this.partIndex !== 0) {\n      this.onPartEnd()\n    }\n    return this.processPartData(data, start, end)\n  }\n\n  private processPartData(data: Buffer, start: number, end: number): Promise<void> {\n    this.actualPartLength += end - start\n    const out = this.out\n    if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\n      return Promise.resolve()\n    }\n    else {\n      return new Promise((resolve, reject) => {\n        out.on(\"error\", reject)\n        out.once(\"drain\", () => {\n          out.removeListener(\"error\", reject)\n          resolve()\n        })\n      })\n    }\n  }\n}"],"sourceRoot":""}
