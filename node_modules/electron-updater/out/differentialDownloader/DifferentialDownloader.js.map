{"version":3,"sources":["../../src/differentialDownloader/DifferentialDownloader.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { BlockMapDataHolder, configureRequestOptionsFromUrl, createHttpError, DigestTransform, HttpExecutor } from \"builder-util-runtime\"\nimport { BlockMap } from \"builder-util-runtime/out/blockMapApi\"\nimport { close, closeSync, createWriteStream, open } from \"fs-extra-p\"\nimport { OutgoingHttpHeaders, RequestOptions } from \"http\"\nimport { Logger } from \"../main\"\nimport { copyData } from \"./DataSplitter\"\nimport { computeOperations, Operation, OperationKind } from \"./downloadPlanBuilder\"\nimport { checkIsRangesSupported, executeTasks } from \"./multipleRangeDownloader\"\n\nconst inflateRaw: any = BluebirdPromise.promisify(require(\"zlib\").inflateRaw)\n\nexport interface DifferentialDownloaderOptions {\n  readonly oldFile: string\n  readonly newUrl: string\n  readonly logger: Logger\n  readonly newFile: string\n\n  readonly requestHeaders: OutgoingHttpHeaders | null\n\n  readonly useMultipleRangeRequest?: boolean\n}\n\nexport abstract class DifferentialDownloader {\n  private readonly baseRequestOptions: RequestOptions\n\n  fileMetadataBuffer: Buffer | null = null\n\n  private readonly logger: Logger\n\n  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected\n  constructor(protected readonly blockAwareFileInfo: BlockMapDataHolder, readonly httpExecutor: HttpExecutor<any>, readonly options: DifferentialDownloaderOptions) {\n    this.logger = options.logger\n    this.baseRequestOptions = configureRequestOptionsFromUrl(options.newUrl, {})\n  }\n\n  createRequestOptions(method: \"head\" | \"get\" = \"get\", newUrl?: string | null): RequestOptions {\n    return {\n      ...(newUrl == null ? this.baseRequestOptions : configureRequestOptionsFromUrl(newUrl, {})),\n      method,\n      headers: {\n        ...this.options.requestHeaders,\n        accept: \"*/*\",\n      } as any,\n    }\n  }\n\n  protected doDownload(oldBlockMap: BlockMap, newBlockMap: BlockMap) {\n    // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it\n    if (oldBlockMap.version !== newBlockMap.version) {\n      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`)\n    }\n\n    const logger = this.logger\n    const operations = computeOperations(oldBlockMap, newBlockMap, logger)\n    if (logger.debug != null) {\n      logger.debug(JSON.stringify(operations, null, 2))\n    }\n\n    let downloadSize = 0\n    let copySize = 0\n    for (const operation of operations) {\n      const length = operation.end - operation.start\n      if (operation.kind === OperationKind.DOWNLOAD) {\n        downloadSize += length\n      }\n      else {\n        copySize += length\n      }\n    }\n\n    const newPackageSize = this.blockAwareFileInfo.size\n    if ((downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length)) !== newPackageSize) {\n      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`)\n    }\n\n    logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`)\n\n    return this.downloadFile(operations)\n  }\n\n  private async downloadFile(tasks: Array<Operation>): Promise<any> {\n    const oldFileFd = await open(this.options.oldFile, \"r\")\n    const newFileFd = await open(this.options.newFile, \"w\")\n    const fileOut = createWriteStream(this.options.newFile, {fd: newFileFd})\n    await new Promise((resolve, reject) => {\n      const streams: Array<any> = []\n      const digestTransform = new DigestTransform(this.blockAwareFileInfo.sha512)\n      // to simply debug, do manual validation to allow file to be fully written\n      digestTransform.isValidateOnEnd = false\n      streams.push(digestTransform)\n\n      // noinspection JSArrowFunctionCanBeReplacedWithShorthand\n      fileOut.on(\"finish\", () => {\n        (fileOut.close as any)(() => {\n          try {\n            digestTransform.validate()\n          }\n          catch (e) {\n            reject(e)\n            return\n          }\n\n          resolve()\n        })\n      })\n\n      streams.push(fileOut)\n\n      let lastStream = null\n      for (const stream of streams) {\n        stream.on(\"error\", reject)\n        if (lastStream == null) {\n          lastStream = stream\n        }\n        else {\n          lastStream = lastStream.pipe(stream)\n        }\n      }\n\n      const firstStream = streams[0]\n\n      let w: any\n      if (this.options.useMultipleRangeRequest) {\n        w = executeTasks(this, tasks, firstStream, oldFileFd, reject)\n      }\n      else {\n        let attemptCount = 0\n        let actualUrl: string | null = null\n        this.logger.info(`Differential download: ${this.options.newUrl}`)\n        w = (index: number) => {\n          if (index >= tasks.length) {\n            if (this.fileMetadataBuffer != null) {\n              firstStream.write(this.fileMetadataBuffer)\n            }\n            firstStream.end()\n            return\n          }\n\n          const operation = tasks[index++]\n          if (operation.kind === OperationKind.COPY) {\n            copyData(operation, firstStream, oldFileFd, reject, () => w(index))\n          }\n          else {\n            const requestOptions = this.createRequestOptions(\"get\", actualUrl)\n            const range = `bytes=${operation.start}-${operation.end - 1}`\n            requestOptions.headers!!.Range = range;\n            (requestOptions as any).redirect = \"manual\"\n\n            const debug = this.logger.debug\n            if (debug != null) {\n              debug(`effective url: ${actualUrl == null ? \"original\" : removeQuery(actualUrl)}, range: ${range}`)\n            }\n\n            const request = this.httpExecutor.doRequest(requestOptions, response => {\n              // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.\n              if (response.statusCode >= 400) {\n                reject(createHttpError(response))\n              }\n\n              response.pipe(firstStream, {\n                end: false\n              })\n              response.once(\"end\", () => {\n                if (++attemptCount === 100) {\n                  attemptCount = 0\n                  setTimeout(() => w(index), 1000)\n                }\n                else {\n                  w(index)\n                }\n              })\n            })\n            request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n              this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`)\n              actualUrl = redirectUrl\n              request.followRedirect()\n            })\n            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n            request.end()\n          }\n        }\n      }\n\n      w(0)\n    })\n      .then(() => close(oldFileFd))\n      .catch(error => {\n        closeSync(oldFileFd)\n        closeSync(newFileFd)\n        throw error\n      })\n  }\n\n  protected async readRemoteBytes(start: number, endInclusive: number) {\n    const buffer = Buffer.allocUnsafe((endInclusive + 1) - start)\n    const requestOptions = this.createRequestOptions()\n    requestOptions.headers!!.Range = `bytes=${start}-${endInclusive}`\n    let position = 0\n    await this.request(requestOptions, chunk => {\n      chunk.copy(buffer, position)\n      position += chunk.length\n    })\n    return buffer\n  }\n\n  private request(requestOptions: RequestOptions, dataHandler: (chunk: Buffer) => void) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpExecutor.doRequest(requestOptions, response => {\n        if (!checkIsRangesSupported(response, reject)) {\n          return\n        }\n\n        response.on(\"data\", dataHandler)\n        response.on(\"end\", () => resolve())\n      })\n      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject)\n      request.end()\n    })\n  }\n}\n\nexport async function readBlockMap(data: Buffer): Promise<BlockMap> {\n  return JSON.parse((await inflateRaw(data)).toString())\n}\n\nfunction formatBytes(value: number, symbol = \" KB\") {\n  return new Intl.NumberFormat(\"en\").format((value / 1024).toFixed(2) as any) + symbol\n}\n\n// safety\nfunction removeQuery(url: string) {\n  const index = url.indexOf(\"?\")\n  return index < 0 ? url : url.substring(0, index)\n}"],"sourceRoot":""}
