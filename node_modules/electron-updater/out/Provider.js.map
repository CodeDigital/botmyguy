{"version":3,"sources":["../src/Provider.ts"],"names":[],"mappings":"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","sourcesContent":["import { CancellationToken, HttpExecutor, newError, safeStringifyJson, UpdateFileInfo, UpdateInfo, WindowsUpdateInfo } from \"builder-util-runtime\"\nimport { OutgoingHttpHeaders, RequestOptions } from \"http\"\nimport { safeLoad } from \"js-yaml\"\nimport { URL } from \"url\"\nimport { newUrlFromBase, ResolvedUpdateFileInfo } from \"./main\"\n\nexport abstract class Provider<T extends UpdateInfo> {\n  private requestHeaders: OutgoingHttpHeaders | null = null\n\n  protected constructor(protected readonly executor: HttpExecutor<any>, readonly useMultipleRangeRequest = true) {\n  }\n\n  get fileExtraDownloadHeaders(): OutgoingHttpHeaders | null {\n    return null\n  }\n\n  setRequestHeaders(value: OutgoingHttpHeaders | null): void {\n    this.requestHeaders = value\n  }\n\n  abstract getLatestVersion(): Promise<T>\n\n  abstract resolveFiles(updateInfo: UpdateInfo): Array<ResolvedUpdateFileInfo>\n\n  /**\n   * Method to perform API request only to resolve update info, but not to download update.\n   */\n  protected httpRequest(url: URL, headers?: OutgoingHttpHeaders | null, cancellationToken?: CancellationToken) {\n    return this.executor.request(this.createRequestOptions(url, headers), cancellationToken)\n  }\n\n  protected createRequestOptions(url: URL, headers?: OutgoingHttpHeaders | null): RequestOptions {\n    const result: RequestOptions = {}\n    if (this.requestHeaders == null) {\n      if (headers != null) {\n        result.headers = headers\n      }\n    }\n    else {\n      result.headers = headers == null ? this.requestHeaders : {...this.requestHeaders, ...headers}\n    }\n\n    configureRequestOptionsFromUrl(url, result)\n    return result\n  }\n}\n\nexport function configureRequestOptionsFromUrl(url: URL, result: RequestOptions): RequestOptions {\n  result.protocol = url.protocol\n  result.hostname = url.hostname\n  if (url.port) {\n    result.port = url.port\n  }\n  result.path = url.pathname + url.search\n  return result\n}\n\nexport function findFile(files: Array<ResolvedUpdateFileInfo>, extension: string, not?: Array<string>): ResolvedUpdateFileInfo | null | undefined  {\n  if (files.length === 0) {\n    throw newError(\"No files provided\", \"ERR_UPDATER_NO_FILES_PROVIDED\")\n  }\n\n  const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`))\n  if (result != null) {\n    return result\n  }\n  else if (not == null) {\n    return files[0]\n  }\n  else {\n    return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)))\n  }\n}\n\nexport function parseUpdateInfo(rawData: string | null, channelFile: string, channelFileUrl: URL): UpdateInfo {\n  if (rawData == null) {\n    throw newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, \"ERR_UPDATER_INVALID_UPDATE_INFO\")\n  }\n\n  let result: UpdateInfo\n  try {\n    result = safeLoad(rawData) as UpdateInfo\n  }\n  catch (e) {\n    throw newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, \"ERR_UPDATER_INVALID_UPDATE_INFO\")\n  }\n  return result\n}\n\nexport function getFileList(updateInfo: UpdateInfo): Array<UpdateFileInfo> {\n  const files = updateInfo.files\n  if (files != null && files.length > 0) {\n    return files\n  }\n\n  if (updateInfo.path != null) {\n    return [\n      {\n        url: updateInfo.path,\n        sha512: updateInfo.sha512,\n      },\n    ]\n  }\n  else {\n    throw newError(`No files provided: ${safeStringifyJson(updateInfo)}`, \"ERR_UPDATER_NO_FILES_PROVIDED\")\n  }\n}\n\nexport function resolveFiles(updateInfo: UpdateInfo, baseUrl: URL, pathTransformer: (p: string) => string = p => p): Array<ResolvedUpdateFileInfo> {\n  const files = getFileList(updateInfo)\n  const result: Array<ResolvedUpdateFileInfo> = files.map(fileInfo => {\n    if ((fileInfo as any).sha2 == null && fileInfo.sha512 == null) {\n      throw newError(`Update info doesn't contain nor sha256 neither sha512 checksum: ${safeStringifyJson(fileInfo)}`, \"ERR_UPDATER_NO_CHECKSUM\")\n    }\n    return {\n      url: newUrlFromBase(pathTransformer(fileInfo.url), baseUrl),\n      info: fileInfo,\n    }\n  })\n\n  const packages = (updateInfo as WindowsUpdateInfo).packages\n  const packageInfo = packages == null ? null : (packages[process.arch] || packages.ia32)\n  if (packageInfo != null) {\n    (result[0] as any).packageInfo = {\n      ...packageInfo,\n      path: newUrlFromBase(pathTransformer(packageInfo.path), baseUrl).href,\n    }\n  }\n  return result\n}"],"sourceRoot":""}
