{"version":3,"sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport isDev from \"electron-is-dev\"\nimport { chmod, unlinkSync } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport \"source-map-support/register\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater } from \"./BaseUpdater\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { UpdateCheckResult } from \"./main\"\nimport { findFile } from \"./providers/Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  checkForUpdatesAndNotify(): Promise<UpdateCheckResult | null> {\n    if (isDev) {\n      return Promise.resolve(null)\n    }\n\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      }\n      else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return Promise.resolve(null)\n    }\n\n    return super.checkForUpdatesAndNotify()\n  }\n\n  /*** @private */\n  protected async doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = await this.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfo), \"AppImage\")!!\n    return await this.executeDownload({\n      fileExtension: \"AppImage\",\n      fileInfo,\n      downloadUpdateOptions,\n      task: async (updateFile, downloadOptions) => {\n        const oldFile = process.env.APPIMAGE!!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, {\n            newUrl: fileInfo.url.href,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            useMultipleRangeRequest: provider.useMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n          })\n            .download()\n        }\n        catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url.href, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected doInstall(installerPath: string, isSilent: boolean, isRunAfter: boolean): boolean {\n    const appImageFile = process.env.APPIMAGE!!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    const existingBaseName = path.basename(appImageFile)\n    // https://github.com/electron-userland/electron-builder/issues/2964\n    // if no version in existing file name, it means that user wants to preserve current custom name\n    if (path.basename(installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    }\n    else {\n      destination = path.join(path.dirname(appImageFile), path.basename(installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", installerPath, destination])\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (isRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      })\n        .unref()\n    }\n    else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], {env})\n    }\n    return true\n  }\n}"],"sourceRoot":""}
