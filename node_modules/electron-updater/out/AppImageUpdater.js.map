{"version":3,"sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, DownloadOptions, newError } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport isDev from \"electron-is-dev\"\nimport { chmod, unlinkSync } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport \"source-map-support/register\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater } from \"./BaseUpdater\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { UpdateCheckResult } from \"./main\"\nimport { findFile } from \"./Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  checkForUpdatesAndNotify(): Promise<UpdateCheckResult | null> {\n    if (isDev) {\n      return Promise.resolve(null)\n    }\n\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      }\n      else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return Promise.resolve(null)\n    }\n\n    return super.checkForUpdatesAndNotify()\n  }\n\n  /*** @private */\n  protected async doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = await this.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfo), \"AppImage\")!!\n\n    const downloadOptions: DownloadOptions = {\n      skipDirCreation: true,\n      headers: downloadUpdateOptions.requestHeaders,\n      cancellationToken: downloadUpdateOptions.cancellationToken,\n      sha512: fileInfo.info.sha512,\n    }\n\n    return await this.executeDownload({\n      fileExtension: \"AppImage\",\n      downloadOptions,\n      fileInfo,\n      updateInfo: downloadUpdateOptions.updateInfo,\n      task: async updateFile => {\n        const oldFile = process.env.APPIMAGE!!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, {\n            newUrl: fileInfo.url.href,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            useMultipleRangeRequest: provider.useMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n          })\n            .download()\n        }\n        catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url.href, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected doInstall(installerPath: string, isSilent: boolean, isRunAfter: boolean): boolean {\n    const appImageFile = process.env.APPIMAGE!!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    const existingBaseName = path.basename(appImageFile)\n    // https://github.com/electron-userland/electron-builder/issues/2964\n    // if no version in existing file name, it means that user wants to preserve current custom name\n    if (path.basename(installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    }\n    else {\n      destination = path.join(path.dirname(appImageFile), path.basename(installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", installerPath, destination])\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (isRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      })\n        .unref()\n    }\n    else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], {env})\n    }\n    return true\n  }\n}"],"sourceRoot":""}
