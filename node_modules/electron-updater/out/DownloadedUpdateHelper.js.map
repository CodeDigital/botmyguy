{"version":3,"sources":["../src/DownloadedUpdateHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { UpdateInfo } from \"builder-util-runtime\"\nimport { createHash } from \"crypto\"\nimport { createReadStream } from \"fs\"\nimport isEqual from \"lodash.isequal\"\nimport { Logger, ResolvedUpdateFileInfo } from \"./main\"\nimport { pathExists, readJson, emptyDir, outputJson } from \"fs-extra-p\"\nimport * as path from \"path\"\n\n/** @private **/\nexport class DownloadedUpdateHelper {\n  private _file: string | null = null\n  private _packageFile: string | null = null\n\n  private versionInfo: UpdateInfo | null = null\n  private fileInfo: ResolvedUpdateFileInfo | null = null\n\n  constructor(readonly cacheDir: string) {\n  }\n\n  get file() {\n    return this._file\n  }\n\n  get packageFile() {\n    return this._packageFile\n  }\n\n  async validateDownloadedPath(updateFile: string, versionInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<string | null> {\n    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {\n      // update has already been downloaded from this running instance\n      // check here only existence, not checksum\n      if (isEqual(this.versionInfo, versionInfo) && isEqual(this.fileInfo.info, fileInfo.info) && (await pathExists(updateFile))) {\n        return updateFile\n      }\n      else {\n        return null\n      }\n    }\n\n    // update has already been downloaded from some previous app launch\n    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger)\n    if (cachedUpdateFile == null) {\n      return null\n    }\n    logger.info(`Update has already been downloaded to ${updateFile}).`)\n    return cachedUpdateFile\n  }\n\n  setDownloadedFile(downloadedFile: string, packageFile: string | null, versionInfo: UpdateInfo, fileInfo: ResolvedUpdateFileInfo) {\n    this._file = downloadedFile\n    this._packageFile = packageFile\n    this.versionInfo = versionInfo\n    this.fileInfo = fileInfo\n  }\n\n  async cacheUpdateInfo(updateFileName: string) {\n    const data: CachedUpdateInfo = {\n      fileName: updateFileName,\n      sha512: this.fileInfo!!.info.sha512,\n    }\n    await outputJson(path.join(this.cacheDir, \"update-info.json\"), data)\n  }\n\n  async clear() {\n    this._file = null\n    this._packageFile = null\n    this.versionInfo = null\n    this.fileInfo = null\n    await this.cleanCacheDir()\n  }\n\n  private async cleanCacheDir(): Promise<void> {\n    try {\n      // remove stale data\n      await emptyDir(this.cacheDir)\n    }\n    catch (ignore) {\n      // ignore\n    }\n  }\n\n  private async getValidCachedUpdateFile(fileInfo: ResolvedUpdateFileInfo, logger: Logger): Promise<string | null> {\n    let cachedInfo: CachedUpdateInfo\n    const updateInfoFile = path.join(this.cacheDir, \"update-info.json\")\n    try {\n      cachedInfo = await readJson(updateInfoFile)\n    }\n    catch (e) {\n      let message = `No cached update info available`\n      if (e.code !== \"ENOENT\") {\n        await this.cleanCacheDir()\n        message += ` (error on read: ${e.message})`\n      }\n      logger.info(message)\n      return null\n    }\n\n    if (cachedInfo.fileName == null) {\n      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`)\n      await this.cleanCacheDir()\n      return null\n    }\n\n    if (fileInfo.info.sha512 !== cachedInfo.sha512) {\n      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`)\n      await this.cleanCacheDir()\n      return null\n    }\n\n    const updateFile = path.join(this.cacheDir, cachedInfo.fileName)\n    if (!(await pathExists(updateFile))) {\n      logger.info(\"Cached update file doesn't exist, directory for cached update will be cleaned\")\n      await this.cleanCacheDir()\n      return null\n    }\n\n    const sha512 = await hashFile(updateFile)\n    if (fileInfo.info.sha512 !== sha512) {\n      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`)\n      await this.cleanCacheDir()\n      return null\n    }\n    return updateFile\n  }\n}\n\ninterface CachedUpdateInfo {\n  fileName: string\n  sha512: string\n}\n\nfunction hashFile(file: string, algorithm: string = \"sha512\", encoding: \"base64\" | \"hex\" = \"base64\", options?: any) {\n  return new Promise<string>((resolve, reject) => {\n    const hash = createHash(algorithm)\n    hash\n      .on(\"error\", reject)\n      .setEncoding(encoding)\n\n    createReadStream(file, {...options, highWaterMark: 1024 * 1024 /* better to use more memory but hash faster */})\n      .on(\"error\", reject)\n      .on(\"end\", () => {\n        hash.end()\n        resolve(hash.read() as string)\n      })\n      .pipe(hash, {end: false})\n  })\n}"],"sourceRoot":""}
