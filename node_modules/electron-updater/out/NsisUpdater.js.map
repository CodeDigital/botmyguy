{"version":3,"sources":["../src/NsisUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, DownloadOptions, newError, PackageFileInfo, BlockMap, CURRENT_APP_PACKAGE_FILE_NAME, CURRENT_APP_INSTALLER_FILE_NAME } from \"builder-util-runtime\"\nimport { spawn } from \"child_process\"\nimport { OutgoingHttpHeaders } from \"http\"\nimport * as path from \"path\"\nimport \"source-map-support/register\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater } from \"./BaseUpdater\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { GenericDifferentialDownloader } from \"./differentialDownloader/GenericDifferentialDownloader\"\nimport { newUrlFromBase, ResolvedUpdateFileInfo } from \"./main\"\nimport { configureRequestOptionsFromUrl, findFile, Provider } from \"./Provider\"\nimport { unlink } from \"fs-extra-p\"\nimport { verifySignature } from \"./windowsExecutableCodeSignatureVerifier\"\nimport { URL } from \"url\"\n\nexport class NsisUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  /*** @private */\n  protected async doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = await this.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfo), \"exe\")!!\n    const downloadOptions: DownloadOptions = {\n      skipDirCreation: true,\n      headers: downloadUpdateOptions.requestHeaders,\n      cancellationToken: downloadUpdateOptions.cancellationToken,\n      sha512: fileInfo.info.sha512,\n    }\n\n    return await this.executeDownload({\n      fileExtension: \"exe\",\n      downloadOptions,\n      fileInfo,\n      updateInfo: downloadUpdateOptions.updateInfo,\n      task: async (destinationFile, packageFile, removeTempDirIfAny) => {\n        const packageInfo = fileInfo.packageInfo\n        const isWebInstaller = packageInfo != null && packageFile != null\n        if (isWebInstaller || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, downloadUpdateOptions.requestHeaders, provider)) {\n          await this.httpExecutor.download(fileInfo.url.href, destinationFile, downloadOptions)\n        }\n\n        const signatureVerificationStatus = await this.verifySignature(destinationFile)\n        if (signatureVerificationStatus != null) {\n          await removeTempDirIfAny()\n          // noinspection ThrowInsideFinallyBlockJS\n          throw newError(`New version ${downloadUpdateOptions.updateInfo!.version} is not signed by the application owner: ${signatureVerificationStatus}`, \"ERR_UPDATER_INVALID_SIGNATURE\")\n        }\n\n        if (isWebInstaller) {\n          if (await this.differentialDownloadWebPackage(packageInfo!!, packageFile!!, provider)) {\n            try {\n              await this.httpExecutor.download(packageInfo!!.path, packageFile!!, {\n                skipDirCreation: true,\n                headers: downloadUpdateOptions.requestHeaders,\n                cancellationToken: downloadUpdateOptions.cancellationToken,\n                sha512: packageInfo!!.sha512,\n              })\n            }\n            catch (e) {\n              try {\n                await unlink(packageFile!!)\n              }\n              catch (ignored) {\n                // ignore\n              }\n\n              throw e\n            }\n          }\n        }\n      },\n    })\n  }\n\n  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\\yyy.exe'\n  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains(\"CN=siemens.com\")})\n  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }\n  private async verifySignature(tempUpdateFile: string): Promise<string | null> {\n    let publisherName: Array<string> | string | null\n    try {\n      publisherName = (await this.configOnDisk.value).publisherName\n      if (publisherName == null) {\n        return null\n      }\n    }\n    catch (e) {\n      if (e.code === \"ENOENT\") {\n        // no app-update.yml\n        return null\n      }\n      throw e\n    }\n    return await verifySignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, this._logger)\n  }\n\n  protected doInstall(installerPath: string, isSilent: boolean, isForceRunAfter: boolean): boolean {\n    const args = [\"--updated\"]\n    if (isSilent) {\n      args.push(\"/S\")\n    }\n\n    if (isForceRunAfter) {\n      args.push(\"--force-run\")\n    }\n\n    const packagePath = this.downloadedUpdateHelper.packageFile\n    if (packagePath != null) {\n      // only = form is supported\n      args.push(`--package-file=\"${packagePath}\"`)\n    }\n\n    const spawnOptions = {\n      detached: true,\n      stdio: \"ignore\",\n    }\n\n    try {\n      spawn(installerPath, args, spawnOptions)\n        .unref()\n    }\n    catch (e) {\n      // yes, such errors dispatched not as error event\n      // https://github.com/electron-userland/electron-builder/issues/1129\n      if ((e as any).code === \"UNKNOWN\" || (e as any).code === \"EACCES\") { // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors\n        this._logger.info(\"Access denied or UNKNOWN error code on spawn, will be executed again using elevate\")\n        try {\n          spawn(path.join(process.resourcesPath!, \"elevate.exe\"), [installerPath].concat(args), spawnOptions)\n            .unref()\n        }\n        catch (e) {\n          this.dispatchError(e)\n        }\n      }\n      else {\n        this.dispatchError(e)\n      }\n    }\n\n    return true\n  }\n\n  // private downloadBlockMap(provider: Provider<any>) {\n  //   await provider.getBytes(newBlockMapUrl, cancellationToken)\n  // }\n\n  private async differentialDownloadInstaller(fileInfo: ResolvedUpdateFileInfo, downloadUpdateOptions: DownloadUpdateOptions, installerPath: string, requestHeaders: OutgoingHttpHeaders, provider: Provider<any>) {\n    try {\n      const newBlockMapUrl = newUrlFromBase(`${fileInfo.url.pathname}.blockmap`, fileInfo.url)\n      const oldBlockMapUrl = newUrlFromBase(`${fileInfo.url.pathname.replace(downloadUpdateOptions.updateInfo.version, this.currentVersion)}.blockmap`, fileInfo.url)\n      this._logger.info(`Download block maps (old: \"${oldBlockMapUrl.href}\", new: ${newBlockMapUrl.href})`)\n\n      const downloadBlockMap = async (url: URL): Promise<BlockMap> => {\n        const requestOptions = configureRequestOptionsFromUrl(url, {headers: downloadUpdateOptions.requestHeaders});\n        (requestOptions as any).gzip = true\n        const data = await this.httpExecutor.request(requestOptions, downloadUpdateOptions.cancellationToken)\n        if (data == null) {\n          throw new Error(`Blockmap \"${url.href}\" is empty`)\n        }\n\n        try {\n          return JSON.parse(data)\n        }\n        catch (e) {\n          throw new Error(`Cannot parse blockmap \"${url.href}\", error: ${e}, raw data: ${data}`)\n        }\n      }\n\n      const blockMapData = await downloadBlockMap(newBlockMapUrl)\n      const oldBlockMapData = await downloadBlockMap(oldBlockMapUrl)\n      await new GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, {\n        newUrl: fileInfo.url.href,\n        oldFile: path.join(this.app.getPath(\"userData\"), CURRENT_APP_INSTALLER_FILE_NAME),\n        logger: this._logger,\n        newFile: installerPath,\n        useMultipleRangeRequest: provider.useMultipleRangeRequest,\n        requestHeaders,\n      })\n        .download(oldBlockMapData, blockMapData)\n    }\n    catch (e) {\n      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n      return true\n    }\n\n    return false\n  }\n\n  private async differentialDownloadWebPackage(packageInfo: PackageFileInfo, packagePath: string, provider: Provider<any>): Promise<boolean> {\n    if (packageInfo.blockMapSize == null) {\n      return true\n    }\n\n    try {\n      await new FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, {\n        newUrl: packageInfo.path,\n        oldFile: path.join(this.app.getPath(\"userData\"), CURRENT_APP_PACKAGE_FILE_NAME),\n        logger: this._logger,\n        newFile: packagePath,\n        requestHeaders: this.requestHeaders,\n        useMultipleRangeRequest: provider.useMultipleRangeRequest,\n      })\n        .download()\n    }\n    catch (e) {\n      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n      // during test (developer machine mac or linux) we must throw error\n      return process.platform === \"win32\"\n    }\n    return false\n  }\n}\n"],"sourceRoot":""}
